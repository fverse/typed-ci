examples {
  ["basic-pipeline"] {
    """
    stages:
    - build
    jobs:
      build-job:
        stage: build
        image: node:18
        script:
        - echo 'Installing dependencies...'
        - npm install
        - echo 'Building project...'
        - npm run build
        artifacts:
          paths:
          - dist/
          - build/
          expire_in: 1 week
        cache:
          paths:
          - node_modules/
          key:
            files:
            - package-lock.json
    
    """
  }
  ["multi-stage-pipeline"] {
    """
    variables:
      NODE_VERSION: '18'
      DEPLOY_ENV:
        value: staging
        description: Target deployment environment
    stages:
    - build
    - test
    - deploy
    default:
      image: node:${NODE_VERSION}
      before_script:
      - echo 'Setting up environment...'
      - node --version
      - npm --version
      cache:
        paths:
        - node_modules/
        key:
          files:
          - package-lock.json
          prefix: npm
        policy: pull-push
    jobs:
      build:
        stage: build
        script:
        - npm ci
        - npm run build
        artifacts:
          paths:
          - dist/
          expire_in: 1 day
      test:unit:
        stage: test
        needs:
        - build
        script:
        - npm ci
        - npm run test:unit
        artifacts:
          when: always
          reports:
            junit: test-results/junit.xml
            coverage_report:
              coverage_format: cobertura
              path: coverage/cobertura-coverage.xml
        coverage: /All files[^|]*\\|[^|]*\\s+([\\d\\.]+)/
      test:integration:
        stage: test
        needs:
        - build
        services:
        - name: postgres:14
          alias: db
        variables:
          DATABASE_URL: postgresql://postgres:password@db:5432/test
        script:
        - npm ci
        - npm run test:integration
        artifacts:
          when: always
          reports:
            junit: test-results/integration-junit.xml
      deploy:staging:
        stage: deploy
        needs:
        - test:unit
        - test:integration
        script:
        - echo 'Deploying to staging environment...'
        - npm run deploy -- --env=staging
        environment:
          name: staging
          url: https://staging.example.com
          deployment_tier: staging
        rules:
        - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    
    """
  }
  ["deploy-pipeline"] {
    """
    variables:
      DOCKER_REGISTRY: registry.example.com
      APP_NAME: my-application
    stages:
    - build
    - deploy
    workflow:
      rules:
      - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      - if: $CI_COMMIT_TAG
    jobs:
      build:docker:
        stage: build
        image: docker:24
        services:
        - docker:24-dind
        variables:
          DOCKER_TLS_CERTDIR: /certs
        before_script:
        - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $DOCKER_REGISTRY
        script:
        - docker build -t $DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA .
        - docker tag $DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA $DOCKER_REGISTRY/$APP_NAME:latest
        - docker push $DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA
        - docker push $DOCKER_REGISTRY/$APP_NAME:latest
        artifacts:
          paths:
          - deployment/
          expire_in: 1 week
      deploy:staging:
        stage: deploy
        image: bitnami/kubectl:latest
        needs:
        - job: build:docker
          artifacts: true
        script:
        - kubectl config use-context staging
        - kubectl set image deployment/$APP_NAME app=$DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA
        - kubectl rollout status deployment/$APP_NAME
        environment:
          name: staging
          url: https://staging.example.com
          deployment_tier: staging
          on_stop: stop:staging
        rules:
        - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      stop:staging:
        stage: deploy
        image: bitnami/kubectl:latest
        script:
        - kubectl config use-context staging
        - kubectl scale deployment/$APP_NAME --replicas=0
        environment:
          name: staging
          action: stop
        when: manual
        rules:
        - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      deploy:production:
        stage: deploy
        image: bitnami/kubectl:latest
        needs:
        - job: build:docker
          artifacts: true
        script:
        - kubectl config use-context production
        - kubectl set image deployment/$APP_NAME app=$DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA
        - kubectl rollout status deployment/$APP_NAME
        environment:
          name: production
          url: https://example.com
          deployment_tier: production
        when: manual
        rules:
        - if: $CI_COMMIT_TAG
        retry:
          max: 2
          when:
          - runner_system_failure
          - stuck_or_timeout_failure
      release:production:
        stage: deploy
        image: registry.gitlab.com/gitlab-org/release-cli:latest
        needs:
        - deploy:production
        script:
        - echo 'Creating release for $CI_COMMIT_TAG'
        release:
          tag_name: $CI_COMMIT_TAG
          name: Release $CI_COMMIT_TAG
          description: Production release $CI_COMMIT_TAG
          assets:
            links:
            - name: Docker Image
              url: $DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA
              link_type: image
        rules:
        - if: $CI_COMMIT_TAG
    
    """
  }
}
facts {
  ["Example files can be imported"] {
    true
  }
}

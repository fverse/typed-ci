/// Deployment Pipeline Example
///
/// This example demonstrates a production deployment pipeline with:
/// - Build stage with artifact generation
/// - Multiple deployment environments (staging and production)
/// - Manual approval for production deployment
/// - Environment-specific configurations
///
/// To use this example:
/// 1. Render to YAML: pkl eval -f yaml deploy-pipeline.pkl > .gitlab-ci.yml
/// 2. Commit the generated .gitlab-ci.yml to your repository
module deploy.pipeline

output {
  renderer = new YamlRenderer {}
}

variables {
  ["DOCKER_REGISTRY"] = "registry.example.com"
  ["APP_NAME"] = "my-application"
}

stages {
  "build"
  "deploy"
}

workflow {
  rules {
    new {
      `if` = "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
    }
    new {
      `if` = "$CI_COMMIT_TAG"
    }
  }
}

jobs {
  ["build:docker"] {
    stage = "build"
    image = "docker:24"
    services {
      "docker:24-dind"
    }
    variables {
      ["DOCKER_TLS_CERTDIR"] = "/certs"
    }
    before_script {
      "docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $DOCKER_REGISTRY"
    }
    script {
      "docker build -t $DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA ."
      "docker tag $DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA $DOCKER_REGISTRY/$APP_NAME:latest"
      "docker push $DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA"
      "docker push $DOCKER_REGISTRY/$APP_NAME:latest"
    }
    artifacts {
      paths {
        "deployment/"
      }
      expire_in = "1 week"
    }
  }
  
  ["deploy:staging"] {
    stage = "deploy"
    image = "bitnami/kubectl:latest"
    needs {
      new {
        job = "build:docker"
        artifacts = true
      }
    }
    script {
      "kubectl config use-context staging"
      "kubectl set image deployment/$APP_NAME app=$DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA"
      "kubectl rollout status deployment/$APP_NAME"
    }
    environment {
      name = "staging"
      url = "https://staging.example.com"
      deployment_tier = "staging"
      on_stop = "stop:staging"
    }
    rules {
      new {
        `if` = "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
      }
    }
  }
  
  ["stop:staging"] {
    stage = "deploy"
    image = "bitnami/kubectl:latest"
    script {
      "kubectl config use-context staging"
      "kubectl scale deployment/$APP_NAME --replicas=0"
    }
    environment {
      name = "staging"
      action = "stop"
    }
    `when` = "manual"
    rules {
      new {
        `if` = "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
      }
    }
  }
  
  ["deploy:production"] {
    stage = "deploy"
    image = "bitnami/kubectl:latest"
    needs {
      new {
        job = "build:docker"
        artifacts = true
      }
    }
    script {
      "kubectl config use-context production"
      "kubectl set image deployment/$APP_NAME app=$DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA"
      "kubectl rollout status deployment/$APP_NAME"
    }
    environment {
      name = "production"
      url = "https://example.com"
      deployment_tier = "production"
    }
    `when` = "manual"
    rules {
      new {
        `if` = "$CI_COMMIT_TAG"
      }
    }
    retry {
      max = 2
      `when` {
        "runner_system_failure"
        "stuck_or_timeout_failure"
      }
    }
  }
  
  ["release:production"] {
    stage = "deploy"
    image = "registry.gitlab.com/gitlab-org/release-cli:latest"
    needs {
      "deploy:production"
    }
    script {
      "echo 'Creating release for $CI_COMMIT_TAG'"
    }
    release {
      tag_name = "$CI_COMMIT_TAG"
      name = "Release $CI_COMMIT_TAG"
      description = "Production release $CI_COMMIT_TAG"
      assets {
        links {
          new {
            name = "Docker Image"
            url = "$DOCKER_REGISTRY/$APP_NAME:$CI_COMMIT_SHA"
            link_type = "image"
          }
        }
      }
    }
    rules {
      new {
        `if` = "$CI_COMMIT_TAG"
      }
    }
  }
}
